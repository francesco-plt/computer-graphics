#include <iostream>
#include <vector>
#include "cylinder.cpp"

void createSpring(
    GLfloat rounds, GLfloat height, GLfloat thickness, GLfloat radius,
    std::vector<GLfloat> &vertices, std::vector<GLuint> &indices)
{
    const int slices = 32;
    const int step = 5;
    for (int i = -slices; i <= rounds * 360 + step; i += step)
    {
        for (int j = 0; j < slices; j++)
        {
            GLfloat t = (GLfloat)i / 360 + (GLfloat)j / slices * step / 360;
            t = std::max(0.0f, std::min(rounds, t));
            GLfloat a1 = t * M_PI * 2;
            GLfloat a2 = (GLfloat)j / slices * M_PI * 2;
            GLfloat d = radius + thickness * cos(a2);
            vertices.push_back(d * cos(a1));
            vertices.push_back(d * sin(a1));
            vertices.push_back(thickness * sin(a2) + height * t / rounds);
        }
    }
    for (GLuint i = 0; i < (GLuint)vertices.size() / 3 - slices; ++i)
    {
        indices.push_back(i);
        indices.push_back(i + slices);
    }
}

// global structure used to ease vertices handling
struct Vertex
{
    double x;
    double y;
    double z;
};

// this function creates the geometries to be shown, and output thems
// in global variables M1_vertices and M1_indices to M4_vertices and M4_indices
void makeModels()
{
    //// M1 : Cube

    // Resizes the vertices array. Repalce the values with the correct number of
    // vertices components (3 * number of vertices)
    // each vertex is a triplet containing x, y and z coordinates of points in space
    // which make up the vertices of polygon models
    std::vector<Vertex> cubeVertices = {
        {0, 0, 0},
        {0, 0, 1},
        {0, 1, 1},
        {0, 1, 0},
        {1, 0, 0},
        {1, 0, 1},
        {1, 1, 1},
        {1, 1, 0},
    };

    M1_vertices.resize(8 * 3);
    for (int i = 0; i < 8; i++)
    {
        M1_vertices[3 * i] = cubeVertices[i].x;
        M1_vertices[3 * i + 1] = cubeVertices[i].y;
        M1_vertices[3 * i + 2] = cubeVertices[i].z;
    }

    // Resizes the indices array. Repalce the values with the correct number of
    // indices (3 * number of triangles)
    M1_indices.resize(36);
    M1_indices = {0, 1, 2, 2, 3, 0, // Index Array:
                  0, 3, 4, 4, 3, 7, // 36 indices
                  5, 6, 7, 7, 4, 5, // to the vertices of
                  1, 6, 5, 1, 2, 6, // 12 triangles composing
                  7, 6, 2, 3, 2, 7, // 6 faces of a cube
                  4, 5, 0, 1, 0, 5};

    //// M2 : Cylinder
    // Resizes the vertices array. Replace the values with the correct number of
    // vertices components (3 * number of vertices)

    int nSlices = 36;
    float cRadius = 1;
    float height = 2;
    // coordinates of the center of the circle
    // which compose the bottom face of the cylinder
    float cx = 0, cy = 0, cz = -3;

    // defining bottom face
    M2_vertices.resize((nSlices + 1) * 2 * 3);

    // Vertices definitions
    M2_vertices[0] = cx;
    M2_vertices[1] = cy + height;
    M2_vertices[2] = cz;
    for (int i = 0; i < nSlices; i++)
    {
        M2_vertices[(i + 1) * 3 + 0] = cx + cRadius * cos((float)(i * 2.0 * M_PI / nSlices)); // x of the vertex
        M2_vertices[(i + 1) * 3 + 1] = cy + height;                                           // y of the vertex
        M2_vertices[(i + 1) * 3 + 2] = cz + cRadius * sin((float)(i * 2.0 * M_PI / nSlices)); // z of the vertex
    }

    M2_vertices[nSlices * 3 + 3] = cx;
    M2_vertices[nSlices * 3 + 4] = cy;
    M2_vertices[nSlices * 3 + 5] = cz;

    for (int i = 0; i < nSlices; i++)
    {
        M2_vertices[(i + nSlices + 2) * 3 + 0] = cx + cRadius * cos((float)(i * 2.0 * M_PI / nSlices)); // x of the vertex
        M2_vertices[(i + nSlices + 2) * 3 + 1] = cy;                                                    // y of the vertex
        M2_vertices[(i + nSlices + 2) * 3 + 2] = cz + cRadius * sin((float)(i * 2.0 * M_PI / nSlices)); // z of the vertex
    }

    // Resizes the indices array. Repalce the values with the correct number of
    // indices (3 * number of triangles)
    M2_indices.resize(20 * nSlices);

    // indices definitions

    for (int i = 0; i < nSlices; i++)
    {
        M2_indices[i * 3] = 0;
        M2_indices[i * 3 + 1] = i + 1;
        M2_indices[i * 3 + 2] = (i + 1) % nSlices + 1;
    }

    for (int i = 0; i < nSlices; i++)
    {
        M2_indices[(i + nSlices) * 3] = nSlices + 1;
        M2_indices[(i + nSlices) * 3 + 1] = nSlices + i + 2;
        M2_indices[(i + nSlices) * 3 + 2] = nSlices + (i + 1) % nSlices + 2;
    }

    // cylinder
    for (int i = 0; i < nSlices * 2; i++)
    {
        M2_indices[2 * 3 * (nSlices + i) + 0] = i + 1;
        M2_indices[2 * 3 * (nSlices + i) + 1] = (i + 1) % nSlices + 1;
        M2_indices[2 * 3 * (nSlices + i) + 2] = nSlices + (i + 1) % nSlices + 1;
        M2_indices[2 * 3 * (nSlices + i) + 3] = nSlices + (i + 1) % nSlices + 1;
        M2_indices[2 * 3 * (nSlices + i) + 4] = nSlices + (i + 1) % nSlices + 2;
        M2_indices[2 * 3 * (nSlices + i) + 5] = (i + 1) % nSlices + 1;
    }

    // M3 : Sphere
    int sphereRes = 12;
    float sRadius = 1;
    Vertex sCenter = {0, 0, 0};
    M3_vertices.resize(sphereRes * sphereRes * 6);
    M3_vertices[0] = sCenter.x;
    M3_vertices[1] = sCenter.y;
    M3_vertices[2] = sCenter.z;

    for (int i = 0; i <= sphereRes; i++)
    {
        for (int j = 0; j <= sphereRes; j++)
        {
            Vertex v = {
                sCenter.x + sRadius * (sin(15 * i * M_PI / 360) * cos(30 * j * M_PI / 360)),
                sCenter.y + sRadius * (cos(15 * i * M_PI / 360)),
                sCenter.z + sRadius * (sin(15 * i * M_PI / 360) * sin(30 * j * M_PI / 360))};

            M3_vertices[i * 3 + j] = v.x;
            M3_vertices[i * 3 + j + 1] = v.y;
            M3_vertices[i * 3 + j + 2] = v.z;
        }
    }

    // Creates indices
    M3_indices.resize(sphereRes * sphereRes * 6);
    for (int i = 0; i < sphereRes; i++)
    {
        for (int j = 0; j < sphereRes; j++)
        {
            M3_indices[sphereRes * (i * sphereRes + j)] = i * 13 + j;
            M3_indices[sphereRes * (i * sphereRes + j) + 1] = i * 13 + j + 1;
            M3_indices[sphereRes * (i * sphereRes + j) + 2] = (i + 1) * 13 + j;
            M3_indices[sphereRes * (i * sphereRes + j) + 3] = i * 13 + j + 1;
            M3_indices[sphereRes * (i * sphereRes + j) + 4] = (i + 1) * 13 + j + 1;
            M3_indices[sphereRes * (i * sphereRes + j) + 5] = (i + 1) * 13 + j;
        }
    }

    //// M4 : Spring
    // Replace the code below, that creates a simple octahedron, with the one to create a spring.
    M4_vertices.resize(1000000);
    M4_indices.resize(1000000);
    createSpring(1.5, 0.25, 0.03, 0.1, M4_vertices, M4_indices);
}