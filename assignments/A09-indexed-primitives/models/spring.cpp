#include <GLFW/glfw3.h>

/*
The center of each circle is located at a distance of spireDist
from the origin in the x-z plane. The x and z coordinates of the
center are calculated using:
x = spireDist * cos(u);
z = spireDist * sin(u);

Next, in the inner loop, the cos and sin are used to calculate the x, y,
and z coordinates of the vertices that make up the spring.

The cos and sin functions are used to calculate the x, y, and z coordinates of each
vertex in spherical coordinates, where u is the angle around the y-axis and
j / nSlices * 2.0 * pi is the angle from the x-y plane.
*/

void createSpring(int nSlices, float steps, float r, float spireDist, int nRounds, float roundsDist)
{
    float u, pi = M_PI;
    float x = 0, y = 0, z = 0;

    for (int i = 0; i < steps; i++)
    {
        float u = (float)i / steps * nRounds * 2.0 * pi;
        x = spireDist * cos(u);
        y = (roundsDist * u) / pi;
        z = spireDist * sin(u);
        for (int j = 0; j < nSlices; j++)
        {
            M4_vertices.push_back(x + r * cos((float)j / nSlices * 2.0 * pi) * cos(u));
            M4_vertices.push_back(y + r * sin((float)j / nSlices * 2.0 * pi));
            M4_vertices.push_back(z + r * cos((float)j / nSlices * 2.0 * pi) * sin(u));
        }
    }

    /*
    The first set of triangles is generated by connecting the current
    vertex of the current slice with the next vertex of the current slice,
    and with the vertex of the same slice of the next step. The second set
    of triangles is generated by connecting the vertex of the same slice
    of the next step with the vertex of the next slice of the next step,
    and with the vertex of the next slice of the current step.
    */

    for (int i = 0; i < steps - 1; i++)
    {
        for (int j = 0; j < nSlices; j++)
        {
            M4_indices.push_back(j + i * nSlices);
            M4_indices.push_back(j + i * nSlices + nSlices);
            M4_indices.push_back(((j + 1) % nSlices) + nSlices * i);

            M4_indices.push_back(j + i * nSlices + nSlices);
            M4_indices.push_back(((j + 1) % nSlices) + nSlices * i + nSlices);
            M4_indices.push_back(((j + 1) % nSlices) + nSlices * i);
        }
    }
}